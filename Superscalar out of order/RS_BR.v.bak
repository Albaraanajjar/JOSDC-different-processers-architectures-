module RS_BR(

input clk, reset, RS_en1, RS_en2,

input v1_d1, v1_d2, v2_d1, v2_d2,
input prediction_d1, prediction_d2, actual_outcome_d1, actual_outcome_d2,
input [4:0] ghr_d1, ghr_d2, tag1_d1, tag1_d2, tag2_d1, tag2_d2, dst_tag_d1, dst_tag_d2,
input [31:0] val1_d1, val1_d2, val2_d1, val2_d2,

input we_INT1, we_INT2, we_MUL, we_LW,
input [4:0] tag_INT1, tag_INT2, tag_MUL, tag_LW,
input [31:0] val_INT1, val_INT2, val_MUL, val_LW,

output update_signal_i, prediction_i, actual_outcome_i,
output [4:0] ghr_i,dst_tag_i,
output [7:0] b_addr_i,
output [31:0]  val1_i, val2_i,
output stall

);


	reg        busy 	            [3:0];
	
	reg        update_signal      [3:0];
	
	reg        prediction         [3:0];
	
	reg        actual_outcome     [3:0];
	
	reg        v1 		            [3:0];
	
	reg 		  v2		            [3:0];
				
	reg [4:0]  ghr		            [3:0];
	
	reg [4:0]  tag1 	            [3:0];
	
	reg [4:0]  tag2 	            [3:0];
	
	reg [4:0]  dst_tag            [3:0];
	
	reg [7:0]  b_addr             [3:0];
		
	reg [31:0] val1 	            [3:0];
	
	reg [31:0] val2               [3:0];
	
	
	
	reg [1:0] disp_p1, disp_p2, iss_p;
	
		
	assign update_signal_i  = update_signal[iss_p];
	
	assign prediction_i     = prediction[iss_p];
	
	assign actual_outcome_i = actual_outcome[iss_p];
	
	assign ghr_i            = dst[iss_p];
		
	assign dst_tag_i        = dst_tag[iss_p];
	
	assign b_addr_i         = b_addr[iss_p];
	
	assign val1_i           = val1[iss_p];
	
	assign val2_i           = val2[iss_p];
	
	
	
	
	always@(posedge clk, posedge reset) begin : MAIN_BLOCK
	
		integer i, j;
		
		reg [1:0] min, d1, d2;
		
		
		if (reset) begin 
		
			for (i = 0; i < 4; i = i + 1) begin
			
				busy               [i] <= 1'b0;
				
				update_signal      [i] <= 1'b0;
				
				prediction         [i] <= 1'b0;
				
				actual_outcome     [i] <= 1'b0;
				
				v1                 [i] <= 1'b1;
				
				v2                 [i] <= 1'b1;
								
				tag1               [i] <= 5'b0;
				
				tag2               [i] <= 5'b0;
				
				ghr                [i] <= 5'b0;
				
				dst_tag            [i] <= 5'b0;
				
				b_addr             [i] <= 8'b0;
				
				val1               [i] <= 32'b0;
				
				val2               [i]	<= 32'b0;
			
			end
			
			disp_p1 <= 2'b0;
		
			disp_p2 <= 2'b0;
			
			iss_p   <= 2'b0;
		
		end
		
		else begin
		
			if ((disp_p1 < 2'd3) & RS_en1) begin
		
				busy           [disp_p1] <= 1'b1;
				
				update_signal  [disp_p1] <= 1'b1;
				
				prediction     [disp_p1] <= prediction_d1;
				
				actual_outcome [disp_p1] <= actual_outcome_d1;
					
				v1             [disp_p1] <= v1_d1;
				
				v2             [disp_p1] <= v2_d1;
										
				tag1           [disp_p1] <= tag1_d1;
					
				tag2           [disp_p1] <= tag2_d1;
				 
				ghr            [disp_p1] <= ghr_d1;
				
				dst_tag        [disp_p1] <= dst_tag_d1;
				
				b_addr         [disp_p1] <= b_addr_d1;
														
				val1           [disp_p1] <= val1_d1;
					
				val2           [disp_p1] <= val2_d1;
								
			end
			
			if ((disp_p2 < 2'd3) & RS_en2) begin
			
				busy           [disp_p2] <= 1'b1;
		
				v1             [disp_p2] <= v1_d2;
				
				v2             [disp_p2] <= v2_d2;

				update_signal  [disp_p2] <= 1'b1;
				
				prediction     [disp_p2] <= prediction_d2;
				
				actual_outcome [disp_p2] <= actual_outcome_d2;
										
				tag1           [disp_p2] <= tag1_d2;
					
				tag2           [disp_p2] <= tag2_d2;
				
				dst            [disp_p2] <= dst_d2;
				
				dst_tag        [disp_p2] <= dst_tag_d2;
				
				b_addr         [disp_p2] <= b_addr_d2;

				val1           [disp_p2] <= val1_d2;
					
				val2    [disp_p2]	<= val2_d2;
								
			end
				
			
			for (j = 0; j < 3; j = j + 1) begin : SNOOPING
			
			
				if ((tag1[j] == tag_INT1) & ~((j == disp_p1) | (j == disp_p2)) & ~v1[j] & busy[j] & we_INT1) begin 
				
					val1 [j] <= val_INT1;
					
					v1   [j] <= 1'b1;
					
				end
				
				if ((tag2[j] == tag_INT1) & ~((j == disp_p1) | (j == disp_p2)) & ~v2[j] & busy[j] & we_INT1) begin
			
					val2 [j] <= val_INT1;
					
					v2   [j] <= 1'b1;
					
				end
				
				if ((tag1[j] == tag_INT2) & ~((j == disp_p1) | (j == disp_p2)) & ~v1[j] & busy[j] & we_INT2) begin
			
					val1 [j] <= val_INT2;
					
					v1   [j] <= 1'b1;
					
				end
				
				if ((tag2[j] == tag_INT2) & ~((j == disp_p1) | (j == disp_p2)) & ~v2[j] & busy[j] & we_INT2) begin
			
					val2 [j] <= val_INT2;
					
					v2   [j] <= 1'b1;
					
				end
				
				if ((tag1[j] == tag_MUL) & ~((j == disp_p1) | (j == disp_p2)) & ~v1[j] & busy[j] & we_MUL) begin
				
					val1 [j]  <= val_MUL;
					
					v1   [j] <= 1'b1;
					
				end
				
				if ((tag2[j] == tag_MUL) & ~((j == disp_p1) | (j == disp_p2)) & ~v2[j] & busy[j] & we_MUL) begin
			
					val2 [j]  <= val_MUL;		
					
					v2   [j]   <= 1'b1;
					
				end
				
				if ((tag1[j] == tag_LW) & ~((j == disp_p1) | (j == disp_p2)) & ~v1[j] & busy[j] & we_LW) begin
				
					val1 [j]  <= val_LW;
					
					v1   [j] <= 1'b1;
					
				end
				
				if ((tag2[j] == tag_LW) & ~((j == disp_p1) | (j == disp_p2)) & ~v2[j] & busy[j] & we_LW) begin
			
					val2 [j]  <= val_LW;		
					
					v2   [j]   <= 1'b1;
					
				end
				
	
			end
			
			
			for (i = 3; i > 0; i = i - 1) if (~busy[i] & ~((disp_p1 == i) & RS_en1)) d1 = i[1:0];
			
			for (i = 3; i > 0; i = i - 1) if (~busy[i] & ~(i == d1) & ~((disp_p1 == i) & RS_en2)) d2 = i[1:0];
			
			if (~busy[0] & ~((disp_p1 == 0) & RS_en1)) begin
			
				d2 = d1;
			
				d1 = 2'b0;
			
			end
			
			disp_p1 <= d1;
			
			disp_p2 <= d2;
			
			
			min = 2'b0;
			
			for (i = 0; i < 3; i = i + 1) begin
			
				if (~(busy [min] & v1[min] & v2[min])) min = i[1:0];
		
				if ((dst_tag[min] > dst_tag[i]) & busy [i] & v1[i] & v2[i]) min = i[1:0];
				
			end
			
			
			if (~(busy [min] & v1[min] & v2[min])) iss_p <= 2'd3;
			
			else iss_p <= min;
			
			
			busy[iss_p] = 1'b0;
			
		end
		
	
	end
	
	assign stall = (disp_p1 == 2'd3) | (disp_p2 == 2'd3);
	

endmodule
