module RS_MUL(

input clk, reset,

input v1_d, v2_d, 
input [4:0] op_d, dst_d, tag1_d, tag2_d, dst_tag_d,
input [31:0] imm_d, val1_d, val2_d,

input [4:0] tag_INT1, tag_INT2, tag_MUL,
input [31:0] val_INT1, val_INT2, val_MUL,

output [4:0] op_i, dst_i, tag1_i, tag2_i, dst_tag_i,
output [31:0] imm_i, val1_i, val2_i,

output stall

);


	reg        busy 	 [3:0];
	
	reg        v1 		 [3:0];
	
	reg 		  v2		 [3:0];
	
	reg [4:0]  op 		 [3:0];
		
	reg [4:0]  dst		 [3:0];
	
	reg [4:0]  tag1 	 [3:0];
	
	reg [4:0]  tag2 	 [3:0];
	
	reg [4:0]  dst_tag [3:0];
	
	reg [31:0] imm		 [3:0];
	
	reg [31:0] val1 	 [3:0];
	
	reg [31:0] val2    [3:0];
	
	
	
	reg [2:0] disp_p, iss_p;
	
	
	assign op_i = op[iss_p];
	
	assign dst_i = dst[iss_p];
	
	assign tag1_i = tag1[iss_p];
	
	assign tag2_i = tag2[iss_p];
		
	assign dst_tag_i = dst_tag[iss_p];
	
	assign imm_i = imm[iss_p];
	
	assign val1_i = val1[iss_p];
	
	assign val2_i = val2[iss_p];
	
	

	
	
	
	always@(posedge clk, posedge reset) begin : MAIN_BLOCK
	
		integer i, j;
		
		reg [2:0] min1, min2, d1, d2;
		
		
		if (reset) begin 
		
			for (i = 0; i < 4; i = i + 1) begin
			
				busy    [i] <= 1'b0;
				
				v1      [i] <= 1'b0;
				
				v2      [i] <= 1'b0;
				
				op      [i] <= 5'b0;
				
				tag1    [i] <= 5'b0;
				
				tag2    [i] <= 5'b0;
				
				dst     [i] <= 5'b0;
				
				dst_tag [i] <= 5'b0;
				
				imm     [i] <= 8'b0;
				
				val1    [i] <= 32'b0;
				
				val2    [i]	<= 32'b0;
			
			end
			
			disp_p <= 3'b0;
			
			iss_p  <= 3'b0;
		
		end
		
		else begin
		
			if (disp_p < 3'd4) begin
		
				busy    [disp_p] <= 1'b1;
					
				v1      [disp_p] <= v1_d;
				
				v2      [disp_p] <= v2_d;
					
				op      [disp_p] <= op_d;
					
				tag1    [disp_p] <= tag1_d;
					
				tag2    [disp_p] <= tag2_d;
				 
				dst     [disp_p] <= dst_d;
				
				dst_tag [disp_p] <= dst_tag_d;
				
				imm     [disp_p] <= imm_d;
					
				val1    [disp_p] <= val1_d;
					
				val2    [disp_p]	<= val2_d;
				
			end
				
			
			for (j = 0; j < 4; j = j + 1) begin : SNOOPING
			
			
				if ((tag1[j] == tag_INT1) & ~(j == disp_p) & ~v1[j] & busy[j]) begin 
				
					val1 [j] <= val_INT1;
					
					v1   [j] <= 1'b1;
					
				end
				
				if ((tag2[j] == tag_INT1) & ~(j == disp_p) & ~v2[j] & busy[j]) begin
			
					val2 [j] <= val_INT1;
					
					v2   [j] <= 1'b1;
					
				end
				
				if ((tag1[j] == tag_INT2) & ~(j == disp_p) & ~v1[j] & busy[j]) begin
			
					val1 [i] <= val_INT2;
					
					v1   [i] <= 1'b1;
					
				end
				
				if ((tag2[j] == tag_INT2) & ~(j == disp_p) & ~v2[j] & busy[j]) begin
			
					val2 [j] <= val_INT2;
					
					v2   [j] <= 1'b1;
					
				end
				
				if ((tag1[j] == tag_MUL) & ~(j == disp_p) & ~v1[j] & busy[j]) begin
				
					val1 [j]  <= val_MUL;
					
					v1   [j] <= 1'b1;
					
				end
				
				if ((tag2[j] == tag_MUL) & ~(j == disp_p) & ~v2[j] & busy[j]) begin
			
					val2 [j]  <= val_MUL;		
					
					v2   [j]   <= 1'b1;
					
				end
				
	
			end
			
			
			for (i = 4; i > 0; i = i - 1) if (~busy[i]) d = i[2:0];
						
			if (~busy[0]) d = 3'b0;
			
			
			
			disp_p1 <= d1[2:0];
						
			
			min1 = 3'b0;
			
			min2 = 3'b0;
			
			for (i = 0; i < 4; i = i + 1) if ((dst_tag[min1] > dst_tag[i]) & busy[i] & v1[i] & v2[i]) min1 = i[2:0];
						
			if (~(busy [min1] & v1[min1] & v2[min1])) iss_p1 <= 3'd4;
			
			else iss_p1 <= min1;
			
			
			
			busy[iss_p1] = 1'b0;
						
			
		end
		
	
	end
	
	assign stall = (disp_p1 > 3'd3);
	

endmodule
