module RS_MEM();

	reg        v1      [7:0];
	
	reg        v2      [7:0];

	reg        lw      [7:0];
	
	reg        sw      [7:0];

	reg [4:0]  tag1    [7:0];
	
	reg [4:0]  tag2    [7:0];
	
	reg [4:0]  dst_tag [7:0];
	
	reg [4:0]  dst     [7:0];
	
	reg [31:0] imm     [7:0];
	
	reg [31:0] val     [7:0];
	
	reg [31:0] data    [7:0];
	
	
	reg [2:0] wr_p, rd_p;
	
	
	assign v1_i      = v1      [rd_p];
	
	assign v2_i      = v2      [rd_p];
	
	assign lw_i      = lw      [rd_p];
	
	assign sw_i      = sw      [rd_p];
	
	assign tag1_i    = tag1    [rd_p];
	
	assign tag2_i    = tag2    [rd_p];
	
	assign dst_tag_i = dst_tag [rd_p];
	
	assign dst       = dst     [rd_p];
	
	assign imm_i     = imm     [rd_p];
	
	assign val_i     = val     [rd_p];
	
	assign data      = data    [rd_p];


	always@(posedge clk, posedge rst) begin : MAIN_BLOCK
	
	
		integer i;
		
		if (rst) begin : RESET
		
			for (i = 0; i < 8; i = i + 1) begin
			
				v1      [i] <= 1'b0;
				
				v2      [i] <= 1'b0;
			
				lw      [i] <= 1'b0;
				
				sw      [i] <= 1'b0;
				
				tag1    [i] <= 5'b0;
				
				tag2    [i] <= 5'b0;
				
				dst_tag [i] <= 5'b0;
				
				dst     [i] <= 5'b0;
				
				imm     [i] <= 32'b0;
				
				val     [i] <= 32'b0;
				
				data    [i] <= 32'b0;
			
			end
			
			wr_p <= 3'b0;
			
			rd_p <= 3'b0;
			
		end
		
		else begin : EXCUTE
		
			if (~stall & RS_en1) begin
			
				v1      [wr_p] <= v1_d1;
				
				v2      [wr_p] <= v2_d1 | lw_d1;
			
				lw      [wr_p] <= lw_d1;
				
				sw      [wr_p] <= sw_d1;
				
				tag1    [wr_p] <= tag1_d1;
				
				tag2    [wr_p] <= tag2_d1;
				
				dst_tag [wr_p] <= dst_tag_d1;
				
				dst     [wr_p] <= dst_d1;
				
				imm     [wr_p] <= imm_d1;
				
				val     [wr_p] <= val_d1;
				
				data    [wr_p] <= data_d1;
			
			end
			
			if (~stall & RS_en2) begin
			
				v1      [wr_p + 3'b1] <= v1_d2;
				
				v2      [wr_p + 3'b1] <= v2_d2 | lw_d2;
			
				lw      [wr_p + 3'b1] <= lw_d2;
				
				sw      [wr_p + 3'b1] <= sw_d2
				
				tag1    [wr_p + 3'b1] <= tag1_d2
				
				tag2    [wr_p + 3'b1] <= tag2_d2;
				
				dst_tag [wr_p + 3'b1] <= dst_tag_d2;
				
				dst     [wr_p + 3'b1] <= dst_d2;
				
				imm     [wr_p + 3'b1] <= imm_d2;
				
				val     [wr_p + 3'b1] <= val_d2;
				
				data    [wr_p + 3'b1] <= data_d2;
			
			end
			
						
			for (i = rd_p; i < {{wr_p[2]},wr_p}; i = i + 1) begin
			
				if ((tag1[i[2:0]] == tag_INT1) & ~v1[i[2:0]] & we_INT1) begin 
				
					val  [i[2:0]] <= val_INT1;
					
					v1   [i[2:0]] <= 1'b1;
					
				end
				
				if ((tag2[i[2:0]] == tag_INT1) & ~v2[i[2:0]] & we_INT1) begin
			
					data [i[2:0]] <= val_INT1;
					
					v2   [i[2:0]] <= 1'b1;
					
				end
				
				if ((tag1[i[2:0]] == tag_INT2) & ~v1[i[2:0]] & we_INT2) begin
			
					val  [i[2:0]] <= val_INT2;
					
					v1   [i[2:0]] <= 1'b1;
					
				end
				
				if ((tag2[i[2:0]] == tag_INT2) & ~v2[i[2:0]] & we_INT2) begin
			
					data [i[2:0]] <= val_INT2;
					
					v2   [i[2:0]] <= 1'b1;
					
				end
				
				if ((tag1i[2:0]] == tag_MUL) & ~v1[i[2:0]] & we_MUL) begin
				
					val  [i[2:0]]  <= val_MUL;
					
					v1   [i[2:0] <= 1'b1;
					
				end
				
				if ((tag2[i[2:0]] == tag_MUL) & ~v2[i[2:0]] & we_MUL) begin
			
					data [i[2:0]]  <= val_MUL;		
					
					v2   [i[2:0]]   <= 1'b1;
				
				end				
			
			end
			
			if (RS_en1 ^ RS_en2) wr_p <= wr_p + 3'b1;
			
			else if (RS_en1 & RS_en2) wr_p <= wr_p + 3'd2;
			
			if (v1[rd_p] & v2[rd_p]) rd_p <= rd_p + 3'b1;
			
			stall <= ((wr_p + 3'b2) == rd_p)
		
		end
	
	
	end

endmodule
